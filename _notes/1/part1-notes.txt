default react tooling:  create-react-app
possible new tooling:  vite


using pnpm instead of npm:
>>pnpx create-react-app
>>pnpm start

react app runs at port 3000 by default

layout of react components are written using JSX (similar to Thymeleaf + Java Spring)
compilation is handled by Babel

components are a feature to enable for code reuseability and maintainability


passing data between components: props

component names should be in capitalcase

top level component needs to be contained in one root element

ideally, use fragments <></> on top level component to avoid an extra <div></div>

objects are not valid as a react child, you can't render objects
you need to retrieve the property values of the object instead

arrays can be rendered as long as it contains an array that are allowed to be rendered (numbers, strings, boolean, etc.)


JavaScript standard = ECMAScript, latest release = June 2022, ECMAScript2022, ES13

Babel = transpile latest js to compatible js code for browsers

NodeJS = js runtime environment based on chrome v8 js engine


variable declarations;
  const = constant, can't be changed
  let = can be changed
  avoid var due to unintended effects


Array = declared as const, still points to the same object even if the contents change

Array.forEach(x=>{...})  // iteration

in ReactJS, we use functional programming where immutability is important
immutability = don't change the value of the variable, instead return a new value

Array.map(x=>{...})  // iterate through array and return new array


Array destructuring

  const a = [7,6,5,4,3,2,1]  // declare array
  const [b, c, ...d] = a     // assign 1st value of a to b, 2nd value of a to c, the rest to d using rest (...) operator


Object literals;

  const obj1 = { prop1: 1, prop2: 2, prop3: false }
  console.log(obj1.prop1)      // 1
  console.log(obj1['prop3'])   // false

  obj1.prop4 = 'new property'
  obj1['prop5'] = 'another new property'   // can only use valid property names


function declaration = where you use 'function' keyword followed by it's name;

  function ThisIsMyFunction() { .... }

function expression = where you use 'function' keyword without it's name;

  const variable = function() { ... }


'this':

  const objX = {
    value: 7,
    objFunc: function() { console.log(value) }
  }
  objX.objFunc2 = function() {... }

  objX.objFunc() // 7

  const referenceToObjFunc = objX.objFunc
  referenceToObjFunc() //undefined

    when we call method by reference:
      1. it loses knowledge of original 'this' (this.value)
      2. 'this' is referred to the global object

  setTimeout(objX.objFunc, 1000)       //undefined
  setTimeout(objX.objFunc.bind(objX))  //7

    calling bind creates a function where 'this' is bound to 'objX' object

Arrow Functions will behave differently depending on how 'this' is used contextually


JavaScript info links:
  https://developer.mozilla.org/en-US/docs/Web/JavaScript/Language_overview
  https://eloquentjavascript.net/


component helper functions:
  functions that are called during rendering



useState() hook
when state changes, the component gets rerendered

events needs to have an assigned "function reference" and not a "function call"
best practice not to define the event handlers inside a component, use a variable to assign a function reference

state needs to be "lifted up" where it should be contained within the component ancestor,
components needs to be written as small as possible and also reuseable

always think of how to simplify the components further